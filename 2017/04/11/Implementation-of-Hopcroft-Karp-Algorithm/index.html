<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>Implementation of Hopcroft-Karp Algorithm | Gao Fangshu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="MathJax.Hub.Config({
    extensions: [&quot;tex2jax.js&quot;],
    &quot;HTML-CSS&quot;: { scale: 10}
  });


See GitHub for my R code.

Several days ago, I made a bet with my roommates that I can find out who are ano">
<meta property="og:type" content="article">
<meta property="og:title" content="Implementation of Hopcroft-Karp Algorithm">
<meta property="og:url" content="http://gaofangshu.com/blog/2017/04/11/Implementation-of-Hopcroft-Karp-Algorithm/index.html">
<meta property="og:site_name" content="Gao Fangshu">
<meta property="og:description" content="MathJax.Hub.Config({
    extensions: [&quot;tex2jax.js&quot;],
    &quot;HTML-CSS&quot;: { scale: 10}
  });


See GitHub for my R code.

Several days ago, I made a bet with my roommates that I can find out who are ano">
<meta property="og:updated_time" content="2017-04-12T04:43:05.178Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Implementation of Hopcroft-Karp Algorithm">
<meta name="twitter:description" content="MathJax.Hub.Config({
    extensions: [&quot;tex2jax.js&quot;],
    &quot;HTML-CSS&quot;: { scale: 10}
  });


See GitHub for my R code.

Several days ago, I made a bet with my roommates that I can find out who are ano">
  
  
    <link rel="icon" href="favicon.ico">
  
  <link href="//fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/blog/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
</head>
<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">Gao Fangshu</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog/" id="subtitle">It is our choices that show what we truly are.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-home-icon" class="nav-icon" href="/blog/"></a>
        
          <a id="nav-tags-icon" class="nav-icon" href="/blog/tags"></a>
        
          <a id="nav-archives-icon" class="nav-icon" href="/blog/archives"></a>
        
          <a id="nav-about-icon" class="nav-icon" href="/blog/about"></a>
        
        
      </nav>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Implementation-of-Hopcroft-Karp-Algorithm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Implementation of Hopcroft-Karp Algorithm
    </h1>
  

      </header>
    
    <time class="article-date" datetime="2017-04-11T01:24:17.000Z" itemprop="datePublished">04-11-2017</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <script type="text/javascript">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    "HTML-CSS": { scale: 10}
  });
</script>

<p><em>See <a href="https://github.com/GaoFangshu/Hopcroft-Karp-algorithm" target="_blank" rel="external">GitHub</a> for my R code.</em></p>
<hr>
<p>Several days ago, I made a bet with my roommates that I can find out who are anonymous reviewers of each student’s graduate thesis. Because 55 professors participate anonymous peer review as advisors and reviewers, names of advisors and ID of anonymous reviewers are known. For each graduate thesis, its advisor and anonymous reviewer cannot be the same person. To sum up all these constraints, maybe we can speculate on the identity of reviewers.</p>
<a id="more"></a>
<p>For example, there are 5 professors (named <code>A, B, C, D, E</code> with ID <code>a, b, c, d, e</code>) in the anonymous peer review. This problem can be described with a matrix.<br>$$<br>\begin{matrix}<br>\quad \\<br>\end{matrix}\begin{matrix}<br> a &amp; b &amp; c &amp; d &amp; e \\<br>\end{matrix}\\\begin{matrix}<br> A \\<br> B \\<br> C \\<br> D \\<br> E \\<br>\end{matrix}\begin{bmatrix}<br> 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\<br> 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\<br> 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\<br> 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\<br> 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{bmatrix}<br>$$</p>
<p>As the matrix above, if professor named <code>A</code> is the anonymous reviewer whose ID is <code>b</code>, then the element with address <code>(A, b)</code> is equal to <code>1</code>. Our goal is to find a possible matrix, based on original matrix, that in each row and column there is only one element equal to <code>1</code>:<br>$$<br>\begin{bmatrix}<br> 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\<br> 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\<br> 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\<br> 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\<br> 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{bmatrix}\Longrightarrow\begin{bmatrix}<br> 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\<br> 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\<br> 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\<br> 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br> 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\<br>\end{bmatrix}<br>$$</p>
<p>First I come up with an enumeration method consisting of two steps:</p>
<p><strong>Step 1. </strong>find all possible matrices that each row and column only has one non-zero element.<br>$$<br>\begin{bmatrix}<br> 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br> 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\<br> 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\<br> 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\<br> 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{bmatrix},\begin{bmatrix}<br> 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\<br> 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br> 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\<br> 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\<br> 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{bmatrix},\begin{bmatrix}<br> 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\<br> 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br> 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\<br> 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\<br> 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{bmatrix}\ldots\begin{bmatrix}<br> 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\<br> 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\<br> 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\<br> 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\<br> 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br>\end{bmatrix}<br>$$</p>
<p><strong>Step 2. </strong>original matrix minus each possible matrix above, and check whether all elements in result are positive. If so, this matrix is the one we look for.<br>$$<br>\begin{align}<br>&amp;\begin{bmatrix}<br> 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\<br> 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\<br> 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\<br> 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\<br> 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{bmatrix}-\begin{bmatrix}<br> 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br> 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\<br> 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\<br> 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\<br> 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{bmatrix}=\begin{bmatrix}<br> -1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\<br> 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\<br> 1 &amp; 0 &amp; -1 &amp; 1 &amp; 1 \\<br> 1 &amp; 1 &amp; 0 &amp; -1 &amp; 0 \\<br> 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\<br>\end{bmatrix}\quad \text{Check next possible matrix.} \\<br>\\<br>&amp;\begin{bmatrix}<br> 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\<br> 1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\<br> 1 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\<br> 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\<br> 0 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{bmatrix}-\begin{bmatrix}<br> 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\<br> 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\<br> 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\<br> 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\<br> 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\<br>\end{bmatrix}=\begin{bmatrix}<br> 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\<br> 1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\<br> 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\<br> 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\<br> 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\<br>\end{bmatrix}\quad \text{A solution is found !}<br>\end{align}<br>$$</p>
<p>This method seems to work, but actually there are \(55!\) possible matrices in the enumeration, which brings a terrible storage burden.</p>
<p>Thus, we need a faster algorithm but not just enumeration. Let’s reconsider our goal, we want to find every advisor’s ID in anonymous review. If we put advisors’ names into a set, anonymous reviews’ ID into another set, our goal is to find a bijection from one set to another.</p>
<p>It is worth noting that, in graph theory, our problem can be regarded as finding a perfect matching in bipartite graphs (to find <em>all</em> perfect matching, refer this <a href="http://www.sciencedirect.com/science/article/pii/0893965994900450" target="_blank" rel="external">paper</a> after we can find <em>one</em> perfect matching). Fortunately, this problem is solved by <a href="https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm" target="_blank" rel="external">Hopcroft–Karp algorithm</a>. (Hopcroft–Karp algorithm is used for searching <em>maximum cardinality matching</em>, however, we can check number of edges to find out perfect matchings)</p>
<p>The intuition of Hopcroft–Karp algorithm is that, after having a set of edges we matched, we try to increase the size (<a href="https://en.wikipedia.org/wiki/Cardinality" target="_blank" rel="external">cardinality</a>) of the set by 1, if success we update the set, until reaching the maximum cardinality. In each iteration, we need to look for an <a href="http://mathworld.wolfram.com/AugmentingPath.html" target="_blank" rel="external">augmenting path</a>, which can be ‘flipped’ to increase the matching size by 1. To visualize Hopcroft–Karp algorithm, this <a href="https://www.youtube.com/watch?v=GPg8qqYWYCY" target="_blank" rel="external">YouTube tutorial</a> is helpful and easy to understand.</p>
<p>My implementation of Hopcroft–Karp algorithm in R is pushed to <a href="">GitHub</a>. However, it may not be implemented in an elegant way, I think there still exist some problems:</p>
<ul>
<li>I use adjacency matrix to represent graph, which has too much space cost. I realize (unfortunately when I nearly finish the program) that array of adjacency lists is a better data structure for this task (see chapter 4.1 in <em><a href="http://algs4.cs.princeton.edu/41graph/" target="_blank" rel="external">Algorithm</a></em>).</li>
<li>It contains to many <code>for</code> and <code>if</code> statements, which is not precise and efficient enough. This problem may be partly caused by adjacency matrix I used.</li>
<li>I try to implement the algorithm by creating and calling lots of functions, but I am not sure whether it is the best way.</li>
</ul>
<p>Here is an example of my implementation:<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">source('C:/Users/Fangshu Gao/Desktop/Advisor/Hopcroft_Karp.R', encoding = 'UTF-<span class="number">8</span>')</div><div class="line">test1 &lt;- matrix(c(<span class="number">1,1,0,0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,</div><div class="line">                  <span class="number">1,0,0,0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,</div><div class="line">                  <span class="number">0,1,0,0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</div><div class="line">                  <span class="number">0,1,0,1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</div><div class="line">                  <span class="number">0,1,0,1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</div><div class="line">                  <span class="number">0,0,1,1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,</div><div class="line">                  <span class="number">0,0,0,0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>), nrow = <span class="number">7</span>, ncol = <span class="number">7</span>, byrow = TRUE)</div><div class="line">test2 &lt;- matrix(c(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,</div><div class="line">                  <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,</div><div class="line">                  <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>), nrow = <span class="number">3</span>, ncol = <span class="number">3</span>, byrow = TRUE)</div><div class="line">MMHK(test1)</div><div class="line">&gt; [<span class="number">1</span>] <span class="number">3 2 4 4</span> <span class="number">6 3 7 6</span> <span class="number">2 1 1 5</span></div><div class="line">MMHK(test2)</div><div class="line">&gt; [<span class="number">1</span>] <span class="number">2 2 3 1</span> <span class="number">1</span> <span class="number">3</span></div></pre></td></tr></table></figure></p>
<p>The result shows that matrix <code>test1</code> has a maximum cardinality matching \( \{(3,2),(4,4),(6,3),(7,6),(2,1),(1,5)\} \) and matrix <code>test2</code> has a perfect matching \( \{(2,2),(3,1),(1,3)\} \).</p>
<p><strong>Further reading:</strong></p>
<ul>
<li>An algorithm summary at Quora: <a href="https://www.quora.com/What-are-some-known-algorithms-for-finding-a-perfect-match-in-a-bipartite-graph" target="_blank" rel="external">What are some known algorithms for finding a perfect match in a bipartite graph?</a></li>
<li>A good <a href="http://www.csie.ntnu.edu.tw/~u91029/Matching.html" target="_blank" rel="external">tutorial</a> on matching.</li>
<li>If you want to count the number of perfect matchings in a planar graph, this <a href="http://aarongorenstein.com/wp-content/uploads/2014/02/fkt.pdf" target="_blank" rel="external">paper</a> may help.</li>
<li>Original <a href="https://pdfs.semanticscholar.org/7e8b/7a7cf3e4954fdacc36db60829ee620e77c96.pdf" target="_blank" rel="external">paper</a> of Hopcroft–Karp algorithm by <a href="https://en.wikipedia.org/wiki/John_Hopcroft" target="_blank" rel="external">John Edward Hopcroft</a> and <a href="https://en.wikipedia.org/wiki/Richard_M._Karp" target="_blank" rel="external">Richard Manning Karp</a>.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://gaofangshu.com/blog/blog/2017/04/11/Implementation-of-Hopcroft-Karp-Algorithm/" data-id="cj2bhz9o20006kwvg75fyj2gw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/R/">R</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2017/05/04/Number-Classification-with-MNIST-Data/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Number Classification with MNIST Data
        
      </div>
    </a>
  
  
    <a href="/blog/2017/03/10/Tricks-for-R-List-and-Order/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Tricks for R: List and Order</div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      Powered by <a href="http://hexo.io" target="_blank" title="Hexo">Hexo</a><br>
      ♡ <a href="http://xushuangblog.com/" target="_blank" title="Xu Shuang">Xu Shuang</a><br>
      &copy; 2016-2017 <a href="http://gaofangshu.com/blog/about/" target="_blank" title="Gao Fangshu">Gao Fangshu</a>
      <br>
    </div>
  </div>
</footer>
    </div>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>

<script type="text/x-mathjax-config"> 
MathJax.Hub.Config({ 
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} 
}); 
</script>
<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  // ################### ADDED ON 2017.04.12 BY GAOFANGSHU ###################
  MathJax.Hub.Config({
    CommonHTML: {matchFontHeight: false},
    "HTML-CSS": {matchFontHeight: false},
    SVG: {matchFontHeight: false}
  // #########################################################################
  });
</script>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>